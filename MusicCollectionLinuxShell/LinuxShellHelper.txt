
using MusicCollectionContext;
using Serilog;
using System;
using System.Diagnostics;
using System.IO;

namespace MusicCollectionLinux
{
    public class MsDosShellHelper
    {
        private StreamWriter _streamWriter;

        public void TreeProcess(CollectionOriginType collectionOriginType, FileSystemContextFilter contextFilter, bool useLinearOutputFormat = true)
        {
            Log.Information("'MsDosShellHelper.TreeProcess' - Started...");

            string rootPath = "";
            string fullFileNameOut;
            string fullFileNameTemp;

            //output files
            if (collectionOriginType == CollectionOriginType.Loss)
            {
                rootPath = Constants.FolderRootCollectionLoss;
                fullFileNameOut = System.IO.Path.Join(rootPath, Constants.TreeTextFileNameCollectionLoss);
                fullFileNameTemp = System.IO.Path.Join(rootPath, Constants.TreeTempFileNameCollectionLoss);
            }
            else
            {
                rootPath = Constants.FolderRootCollectionLossLess;
                fullFileNameOut = System.IO.Path.Join(rootPath, Constants.TreeTextFileNameCollectionLossLess);
                fullFileNameTemp = System.IO.Path.Join(rootPath, Constants.TreeTempFileNameCollectionLossLess);
            }

            if (useLinearOutputFormat)
                fullFileNameTemp = fullFileNameOut;

            //make dos command

            //TODO: Extensions filter

            //https://ss64.com/nt/dir.html
            //  /S     - All sub-folders (tree)
            //  /A:-D  - Get all except folders
            //  /A:D   - Get only folders
            //  /B     - linear output format, Bare format (no heading, file sizes or summary).

            string msDosCommand = "";

            if (useLinearOutputFormat)
            {
                switch (contextFilter)
                {
                    case FileSystemContextFilter.All:
                        msDosCommand = $"/C chcp 65001 & dir /S /B {rootPath}";
                        break;
                    case FileSystemContextFilter.DirectoriesOnly:
                        msDosCommand = $"/C chcp 65001 & dir /S /A:D /B {rootPath}";
                        break;
                    case FileSystemContextFilter.FilesOnly:
                        msDosCommand = $"/C chcp 65001 & dir /S /A:-D /B {rootPath}";
                        break;
                }
            }
            else
                msDosCommand = $"/C chcp 65001 & dir /S {rootPath}";

            //process 
            bool result = MsDosProcess(msDosCommand, fullFileNameTemp);

            if ((result) && (!useLinearOutputFormat))
                ChangeOutputToLinearFormat(fullFileNameTemp, fullFileNameOut, contextFilter);

            Log.Information("'MsDosShellHelper.TreeProcess' - Finished...");
        }

        private bool MsDosProcess(string msDosCommand, string fullFileNameOut)
        {
            bool retValue = true; 

            try
            {
                //output
                _streamWriter = new StreamWriter(fullFileNameOut, false, Constants.StreamsEncoding);

                //Process Info
                System.Diagnostics.ProcessStartInfo startInfo = new();
                startInfo.FileName = "cmd.exe";
                startInfo.Arguments = msDosCommand;

                //dos without window
                //startInfo.WindowStyle = System.Diagnostics.ProcessWindowStyle.Hidden;
                //startInfo.UseShellExecute = false;
                //startInfo.CreateNoWindow = false;

                //output to files
                startInfo.RedirectStandardOutput = true;
                startInfo.RedirectStandardError = true;

                //Process
                System.Diagnostics.Process process = new();
                process.StartInfo = startInfo;

                //V1
                process.OutputDataReceived += OutputDataReceived;
                process.ErrorDataReceived += ErrorDataReceived;

                //V2
                //process.OutputDataReceived += (sender, args) =>
                //{
                //    _streamWriter.WriteLine(args.Data);
                //    _streamWriter.Flush();
                //};

                //process.OutputDataReceived += (sender, args) =>
                //{
                //    _streamWriter.WriteLine("ERROR:" + args.Data);
                //    _streamWriter.Flush();
                //};

                //Start
                process.Start();
                process.BeginOutputReadLine(); //important to file output 
                process.WaitForExit();
            }
            catch (Exception ex)
            {
                Log.Error($"Command:{msDosCommand}");
                Log.Error($"Outout:{fullFileNameOut}");
                Log.Error($"Message Error:{ex.Message}");
                retValue = false;
            }
            finally
            {
                if (_streamWriter != null)
                {
                    _streamWriter.Flush();
                    _streamWriter.Close();
                    _streamWriter.Dispose();
                }
            }

            return retValue;
        }

        private void ErrorDataReceived(object sender, DataReceivedEventArgs e)
        {
            _streamWriter.WriteLine("ERROR:" + e.Data);
            _streamWriter.Flush();
        }

        private void OutputDataReceived(object sender, DataReceivedEventArgs e)
        {
            _streamWriter.WriteLine(e.Data);
            _streamWriter.Flush();
        }

        /// <summary>
        /// set output like: "dir /B"
        /// </summary>
        /// <param name="contextFilter"></param>
        private void ChangeOutputToLinearFormat(string fullFileNameTemp, string fullFileNameOut, FileSystemContextFilter contextFilter)
        {
            if (!File.Exists(fullFileNameTemp))
                return;

            StreamReader reader = null;
            StreamWriter writer = null;
            int count = 0;
            string line = "";

            try
            {
                reader = new StreamReader(fullFileNameTemp, Constants.StreamsEncoding);
                writer = new StreamWriter(fullFileNameOut, false, Constants.StreamsEncoding);

                bool isFolder = false;
                string baseDir = "";
                string member;
                DateTime dt;

                while ((line = reader.ReadLine()) != null)
                {
                    if (line.Length < 14)
                        continue;


                    if (line.Substring(0, 14) == " Directory of ")
                    {
                        baseDir = line.Substring(14);
                        continue;
                    }

                    if (line.Length < 37)
                        continue;

                    if (!DateTime.TryParse(line.Substring(0,10), out dt))
                        continue;

                    isFolder = (line.Substring(21, 5) == "<DIR>");

                    member = line.Substring(36);

                    if (isFolder && (member == ".") || (member == ".."))
                        continue;

                    //

                    if (isFolder)
                    {
                        if (contextFilter == FileSystemContextFilter.FilesOnly)
                            continue;
                    }
                    else
                    {
                        if (contextFilter == FileSystemContextFilter.DirectoriesOnly)
                            continue;
                    }

                     writer.WriteLine($"{baseDir}{Path.DirectorySeparatorChar}{member}");
                    writer.Flush();
                }

                Log.Information(count.ToString());

            }
            catch (Exception ex)
            {
                Log.Error($"Line:{line}");
                Log.Error($"Outout:{fullFileNameOut}");
                Log.Error($"Message Error:{ex.Message}");
            }
            finally
            {
                if (reader != null)
                {
                    reader.Close();
                    reader.Dispose();
                }
                if (writer != null)
                {
                    writer.Flush();
                    writer.Close();
                    writer.Dispose();
                }
            }
        }


 
    }
}


